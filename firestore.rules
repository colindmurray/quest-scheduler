rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isEmailVerified() {
      return request.auth.token.email_verified == true
        || request.auth.token.firebase.sign_in_provider == 'google.com'
        || request.auth.token.firebase.sign_in_provider == 'custom';
    }

    function userEmail() {
      return request.auth.token.email != null
        ? request.auth.token.email.lower()
        : null;
    }

    function isCreator(data) {
      return isSignedIn() && data.creatorId == request.auth.uid;
    }

    function hasPendingInvite(data) {
      return data.pendingInvites != null && userEmail() in data.pendingInvites;
    }

    function isQuestingGroupMember(data) {
      return isSignedIn()
        && data.questingGroupId != null
        && data.questingGroupId != ""
        && exists(/databases/$(database)/documents/questingGroups/$(data.questingGroupId))
        && (get(/databases/$(database)/documents/questingGroups/$(data.questingGroupId)).data.memberIds != null
          && request.auth.uid in get(/databases/$(database)/documents/questingGroups/$(data.questingGroupId)).data.memberIds);
    }

    function isSchedulerParticipantData(data) {
      return isSignedIn() && (
        (data.participantIds != null && request.auth.uid in data.participantIds)
      );
    }

    function canReadScheduler(data) {
      return isSignedIn() && (
        isCreator(data) ||
        isSchedulerParticipantData(data) ||
        isQuestingGroupMember(data) ||
        hasPendingInvite(data) ||
        data.allowLinkSharing == true
      );
    }

    match /users/{userId} {
      function protectedUserFieldsUnchanged() {
        return resource == null
          ? !request.resource.data.keys().hasAny([
              "inviteAllowance",
              "suspended",
              "suspendedAt",
              "discord",
              "qsUsername"
            ])
          : !request.resource.data.diff(resource.data).affectedKeys().hasAny([
              "inviteAllowance",
              "suspended",
              "suspendedAt",
              "discord",
              "qsUsername"
            ]);
      }

      allow read: if isSignedIn() && request.auth.uid == userId;
      allow write: if isSignedIn()
        && request.auth.uid == userId
        && protectedUserFieldsUnchanged();

      // Notifications subcollection - user can only access their own
      match /notifications/{notificationId} {
        allow read, update: if isSignedIn() && request.auth.uid == userId;
        allow delete: if isSignedIn() && (
          request.auth.uid == userId ||
          (resource.data.type in ["GROUP_INVITE", "POLL_INVITE"]
            && resource.data.metadata.inviterEmail == userEmail())
        );
        allow create: if isSignedIn()
          && request.resource.data.type in [
            "FRIEND_REQUEST",
            "FRIEND_ACCEPTED",
            "POLL_INVITE",
            "GROUP_INVITE",
            "GROUP_INVITE_ACCEPTED",
            "SESSION_INVITE",
            "VOTE_REMINDER",
            "VOTE_SUBMITTED",
            "SESSION_FINALIZED",
            "SESSION_JOINED",
            "GROUP_MEMBER_CHANGE"
          ]
          && request.resource.data.read == false
          && request.resource.data.dismissed == false;
      }

      match /blockedUsers/{blockId} {
        allow read: if isSignedIn() && request.auth.uid == userId;
        allow write: if false;
      }
    }

    match /notificationEvents/{eventId} {
      allow read, write: if false;
    }

    match /pendingNotifications/{emailHash}/events/{eventId} {
      allow read, write: if false;
    }

    match /feedbackSubmissions/{submissionId} {
      allow read, update, delete: if false;
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.title is string
        && request.resource.data.issueType is string
        && request.resource.data.description is string
        && request.resource.data.userEmail == request.auth.token.email;
    }

    match /usersPublic/{userId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == userId;
    }

    match /qsUsernames/{usernameLower} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /bannedEmails/{emailId} {
      allow read: if isSignedIn()
        && request.auth.token.email != null
        && (resource == null || resource.data.email == request.auth.token.email);
      allow write: if false;
    }

    match /userSecrets/{userId} {
      allow read, write: if false;
    }

    match /oauthStates/{stateId} {
      allow read, write: if false;
    }

    match /discordUserLinks/{discordUserId} {
      allow read, write: if false;
    }

    match /discordLinkCodes/{codeId} {
      allow read, write: if false;
    }

    match /discordVoteSessions/{sessionId} {
      allow read, write: if false;
    }

    match /discordInteractionIds/{interactionId} {
      allow read, write: if false;
    }

    match /questingGroups/{groupId} {
      function isGroupMember(data) {
        return (data.memberIds != null && request.auth.uid in data.memberIds);
      }

      function isGroupInvitee(data) {
        return userEmail() in data.pendingInvites;
      }

      function isGroupManager(data) {
        return data.creatorId == request.auth.uid
          || (data.memberManaged == true && isGroupMember(data));
      }

      function managerUpdateAllowed(data) {
        return isGroupManager(data)
          && !request.resource.data.diff(data).affectedKeys().hasAny([
            "pendingInvites",
            "pendingInviteMeta"
          ]);
      }

      function isInviteeUpdate(data) {
        return isGroupInvitee(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "memberIds",
            "pendingInvites",
            "pendingInviteMeta",
            "updatedAt"
          ])
          && data.pendingInvites.size() == request.resource.data.pendingInvites.size() + 1
          && !(userEmail() in request.resource.data.pendingInvites)
          && data.pendingInvites.hasAll(request.resource.data.pendingInvites)
          && request.resource.data.memberIds.hasAll(data.memberIds)
          && request.resource.data.memberIds.size() <= data.memberIds.size() + 1
          && (
            request.resource.data.memberIds.size() == data.memberIds.size()
            || request.auth.uid in request.resource.data.memberIds
          );
      }

      function isSelfLeave(data) {
        return isGroupMember(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "memberIds",
            "updatedAt"
          ])
          && request.auth.uid in data.memberIds
          && !(request.auth.uid in request.resource.data.memberIds)
          && data.memberIds.size() == request.resource.data.memberIds.size() + 1
          && data.memberIds.hasAll(request.resource.data.memberIds);
      }

      // Read: members, pending invites, or creator can read
      allow read: if isSignedIn() && (
        isGroupMember(resource.data) ||
        isGroupInvitee(resource.data) ||
        resource.data.creatorId == request.auth.uid
      );

      // Create: any authenticated user can create a group
      allow create: if isSignedIn()
        && isEmailVerified()
        && request.resource.data.creatorId == request.auth.uid;

      // Update: creator always can update, members can update if memberManaged is true, invitees can accept/decline
      allow update: if isSignedIn() && (
        managerUpdateAllowed(resource.data) ||
        isInviteeUpdate(resource.data) ||
        isSelfLeave(resource.data)
      );

      // Delete: creator only
      allow delete: if isSignedIn() && resource.data.creatorId == request.auth.uid;
    }

    match /schedulers/{schedulerId} {
      function isSchedulerParticipant(data) {
        return isSchedulerParticipantData(data);
      }

      function canVoteScheduler(data) {
        return isSignedIn() && (
          (data.participantIds != null && request.auth.uid in data.participantIds) ||
          isQuestingGroupMember(data)
        );
      }

      function isSchedulerInvitee(data) {
        return isSignedIn() && hasPendingInvite(data);
      }

      function isInviteeUpdate(data) {
        return data.pendingInvites != null
          && isSchedulerInvitee(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "participantIds",
            "pendingInvites",
            "pendingInviteMeta",
            "updatedAt"
          ])
          && data.pendingInvites.size() == request.resource.data.pendingInvites.size() + 1
          && !(userEmail() in request.resource.data.pendingInvites)
          && data.pendingInvites.hasAll(request.resource.data.pendingInvites)
          && (
            (
              request.resource.data.participantIds.size() == data.participantIds.size()
              && request.resource.data.participantIds.hasAll(data.participantIds)
            )
            || (
              request.resource.data.participantIds.size() == data.participantIds.size() + 1
              && request.auth.uid in request.resource.data.participantIds
              && request.resource.data.participantIds.hasAll(data.participantIds)
            )
            || (
              request.resource.data.participantIds.size() + 1 == data.participantIds.size()
              && request.auth.uid in data.participantIds
              && !(request.auth.uid in request.resource.data.participantIds)
              && data.participantIds.hasAll(request.resource.data.participantIds)
            )
          );
      }

      function isLinkShareJoin(data) {
        return isSignedIn()
          && data.allowLinkSharing == true
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "participantIds",
            "pendingInvites",
            "pendingInviteMeta",
            "updatedAt"
          ])
          && request.resource.data.participantIds.size() == data.participantIds.size() + 1
          && request.auth.uid in request.resource.data.participantIds
          && request.resource.data.participantIds.hasAll(data.participantIds);
      }

      function isSelfLeave(data) {
        return isSchedulerParticipant(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "participantIds",
            "updatedAt"
          ])
          && request.auth.uid in data.participantIds
          && !(request.auth.uid in request.resource.data.participantIds)
          && data.participantIds.size() == request.resource.data.participantIds.size() + 1
          && data.participantIds.hasAll(request.resource.data.participantIds);
      }

      function creatorUpdateAllowed(data) {
        return isCreator(data)
          && !request.resource.data.diff(data).affectedKeys().hasAny([
            "pendingInvites",
            "pendingInviteMeta"
          ]);
      }

      allow read: if canReadScheduler(resource.data);
      allow create: if isSignedIn()
        && isEmailVerified()
        && request.resource.data.creatorId == request.auth.uid
        && (!request.resource.data.keys().hasAny(["pendingInviteMeta"]))
        && (request.resource.data.pendingInvites == null
          || request.resource.data.pendingInvites.size() == 0);

      allow update: if creatorUpdateAllowed(resource.data)
        || isInviteeUpdate(resource.data)
        || isLinkShareJoin(resource.data)
        || isSelfLeave(resource.data);

      allow delete: if isCreator(resource.data);

      match /slots/{slotId} {
        allow read: if canReadScheduler(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data);
        allow write: if isCreator(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data);
      }

      match /votes/{userId} {
        allow read: if canReadScheduler(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data);
        function creatorVoteUpdateAllowed(voteData) {
          return voteData != null
            && isCreator(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data)
            && request.resource.data.diff(voteData).affectedKeys().hasOnly(["votes", "updatedAt"])
            && voteData.votes != null
            && request.resource.data.votes != null
            && request.resource.data.votes.keys().hasOnly(voteData.votes.keys());
        }

        allow create, update: if isSignedIn()
          && (
            (request.auth.uid == userId
              && canVoteScheduler(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data))
            || creatorVoteUpdateAllowed(resource.data)
          );
        allow delete: if isSignedIn() && (
          (request.auth.uid == userId
            && canVoteScheduler(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data))
          || isCreator(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data)
        );
      }
    }

    match /friendRequests/{requestId} {
      allow create: if false;

      allow read: if isSignedIn() && (
        resource == null ||
        request.auth.uid == resource.data.fromUserId ||
        userEmail() == resource.data.toEmail ||
        userEmail() == resource.data.fromEmail
      );

      allow update: if isSignedIn() && (
        (
          userEmail() == resource.data.toEmail &&
          resource.data.status == "pending" &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(["status", "respondedAt", "toUserId"]) &&
          request.resource.data.status in ["accepted", "declined"]
        ) ||
        (
          (request.auth.uid == resource.data.fromUserId ||
            userEmail() == resource.data.toEmail ||
            userEmail() == resource.data.fromEmail) &&
          resource.data.status == "accepted" &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(["status", "respondedAt"]) &&
          request.resource.data.status == "removed"
        )
      );

      allow delete: if isSignedIn()
        && (userEmail() == resource.data.fromEmail
          || userEmail() == resource.data.toEmail)
        && resource.data.status in ["accepted", "removed"];
    }

    match /mail/{docId} {
      allow create: if isSignedIn();
      allow read, update, delete: if false;
    }
  }
}
