rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isEmailVerified() {
      return request.auth.token.email_verified == true
        || request.auth.token.firebase.sign_in_provider == 'google.com'
        || request.auth.token.firebase.sign_in_provider == 'custom';
    }

    function isRequester(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function requesterIn(ids) {
      return request.auth != null
        && ids != null
        && request.auth.uid in ids;
    }

    function userEmail() {
      return request.auth != null && request.auth.token.email != null
        ? request.auth.token.email.lower()
        : null;
    }

    function isCreator(data) {
      return isSignedIn()
        ? (data == null ? false : data.creatorId == request.auth.uid)
        : false;
    }

    function hasPendingInvite(data) {
      return isSignedIn()
        ? (
          data != null
          && data.pendingInvites != null
          && userEmail() != null
          && userEmail() in data.pendingInvites
        )
        : false;
    }

    function isQuestingGroupMember(data) {
      return isSignedIn()
        ? (
          data != null
          && data.questingGroupId != null
          && data.questingGroupId != ""
          && exists(/databases/$(database)/documents/questingGroups/$(data.questingGroupId))
          && (get(/databases/$(database)/documents/questingGroups/$(data.questingGroupId)).data.memberIds != null
            && requesterIn(get(/databases/$(database)/documents/questingGroups/$(data.questingGroupId)).data.memberIds))
        )
        : false;
    }

    function isSchedulerParticipantData(data) {
      return isSignedIn()
        ? (data == null ? false : requesterIn(data.participantIds))
        : false;
    }

    function canReadScheduler(data) {
      return data != null && isSignedIn() && (
        isCreator(data) ||
        isSchedulerParticipantData(data) ||
        isQuestingGroupMember(data) ||
        hasPendingInvite(data) ||
        (data != null && data.allowLinkSharing == true)
      );
    }

    match /users/{userId} {
      function protectedUserFieldsUnchanged() {
        return resource == null
          ? !request.resource.data.keys().hasAny([
              "inviteAllowance",
              "suspended",
              "suspendedAt",
              "discord",
              "qsUsername"
            ])
          : !request.resource.data.diff(resource.data).affectedKeys().hasAny([
              "inviteAllowance",
              "suspended",
              "suspendedAt",
              "discord",
              "qsUsername"
            ]);
      }

      allow read: if isSignedIn() && request.auth.uid == userId;
      allow write: if isSignedIn()
        && request.auth.uid == userId
        && protectedUserFieldsUnchanged();

      // Notifications subcollection - user can only access their own
      match /notifications/{notificationId} {
        allow read, update: if isSignedIn() && request.auth.uid == userId;
        allow delete: if isSignedIn() && (
          request.auth.uid == userId ||
          (resource.data.type in ["GROUP_INVITE", "POLL_INVITE"]
            && resource.data.metadata.inviterEmail == userEmail())
        );
        allow create: if isSignedIn()
          && request.resource.data.type in [
            "FRIEND_REQUEST",
            "FRIEND_ACCEPTED",
            "POLL_INVITE",
            "GROUP_INVITE",
            "GROUP_INVITE_ACCEPTED",
            "SESSION_INVITE",
            "VOTE_REMINDER",
            "VOTE_SUBMITTED",
            "SESSION_FINALIZED",
            "SESSION_JOINED",
            "GROUP_MEMBER_CHANGE"
          ]
          && request.resource.data.read == false
          && request.resource.data.dismissed == false;
      }

      match /blockedUsers/{blockId} {
        allow read: if isSignedIn() && request.auth.uid == userId;
        allow write: if false;
      }
    }

    match /notificationEvents/{eventId} {
      allow read, write: if false;
    }

    match /pendingNotifications/{emailHash}/events/{eventId} {
      allow read, write: if false;
    }

    match /feedbackSubmissions/{submissionId} {
      allow read, update, delete: if false;
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.title is string
        && request.resource.data.issueType is string
        && request.resource.data.description is string
        && request.resource.data.userEmail == request.auth.token.email;
    }

    match /usersPublic/{userId} {
      function usersPublicProtectedFieldsUnchanged() {
        return resource == null
          ? !request.resource.data.keys().hasAny(["busyWindows"])
          : !request.resource.data.diff(resource.data).affectedKeys().hasAny(["busyWindows"]);
      }
      allow read: if isSignedIn();
      allow write: if isSignedIn()
        && request.auth.uid == userId
        && usersPublicProtectedFieldsUnchanged();
    }

    match /qsUsernames/{usernameLower} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /bannedEmails/{emailId} {
      allow read: if isSignedIn()
        && request.auth.token.email != null
        && (resource == null || resource.data.email == request.auth.token.email);
      allow write: if false;
    }

    match /userSecrets/{userId} {
      allow read, write: if false;
    }

    match /oauthStates/{stateId} {
      allow read, write: if false;
    }

    match /discordUserLinks/{discordUserId} {
      allow read, write: if false;
    }

    match /discordLinkCodes/{codeId} {
      allow read, write: if false;
    }

    match /discordVoteSessions/{sessionId} {
      allow read, write: if false;
    }

    match /discordInteractionIds/{interactionId} {
      allow read, write: if false;
    }

    match /questingGroups/{groupId} {
      function isGroupMember(data) {
        return isSignedIn()
          ? (data == null ? false : requesterIn(data.memberIds))
          : false;
      }

      function isGroupInvitee(data) {
        return isSignedIn()
          ? (
            data != null
            && data.pendingInvites != null
            && userEmail() != null
            && userEmail() in data.pendingInvites
          )
          : false;
      }

      function isGroupManager(data) {
        return isSignedIn() && data != null && (
          data.creatorId == request.auth.uid
          || (data.memberManaged == true && isGroupMember(data))
        );
      }

      function managerUpdateAllowed(data) {
        return isGroupManager(data)
          && !request.resource.data.diff(data).affectedKeys().hasAny([
            "pendingInvites",
            "pendingInviteMeta"
          ]);
      }

      function isInviteeUpdate(data) {
        return isGroupInvitee(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "memberIds",
            "pendingInvites",
            "pendingInviteMeta",
            "updatedAt"
          ])
          && data.pendingInvites.size() == request.resource.data.pendingInvites.size() + 1
          && !(userEmail() in request.resource.data.pendingInvites)
          && data.pendingInvites.hasAll(request.resource.data.pendingInvites)
          && request.resource.data.memberIds.hasAll(data.memberIds)
          && request.resource.data.memberIds.size() <= data.memberIds.size() + 1
          && (
            request.resource.data.memberIds.size() == data.memberIds.size()
            || request.auth.uid in request.resource.data.memberIds
          );
      }

      function isSelfLeave(data) {
        return isGroupMember(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "memberIds",
            "updatedAt"
          ])
          && request.auth.uid in data.memberIds
          && !(request.auth.uid in request.resource.data.memberIds)
          && data.memberIds.size() == request.resource.data.memberIds.size() + 1
          && data.memberIds.hasAll(request.resource.data.memberIds);
      }

      // Read: members, pending invites, or creator can read
      allow read: if resource != null && isSignedIn() && (
        isGroupMember(resource.data) ||
        isGroupInvitee(resource.data) ||
        resource.data.creatorId == request.auth.uid
      );

      // Create: any authenticated user can create a group
      allow create: if isSignedIn()
        && isEmailVerified()
        && request.resource.data.creatorId == request.auth.uid;

      // Update: creator always can update, members can update if memberManaged is true, invitees can accept/decline
      allow update: if isSignedIn() && (
        managerUpdateAllowed(resource.data) ||
        isInviteeUpdate(resource.data) ||
        isSelfLeave(resource.data)
      );

      // Delete: creator only
      allow delete: if isSignedIn() && resource.data.creatorId == request.auth.uid;

      match /basicPolls/{pollId} {
        function groupData() {
          return exists(/databases/$(database)/documents/questingGroups/$(groupId))
            ? get(/databases/$(database)/documents/questingGroups/$(groupId)).data
            : null;
        }

        function canReadGroupBasicPoll() {
          return isSignedIn()
            && groupData() != null
            && isGroupMember(groupData());
        }

        function canManageGroupBasicPoll() {
          return isSignedIn()
            && groupData() != null
            && isGroupManager(groupData());
        }

        function isGroupBasicPollWritable(data) {
          return data == null
            ? false
            : (
              data.status == "OPEN"
              && (
                !(data.keys().hasAny(["deadlineAt"]) && data.deadlineAt != null)
                || request.time < data.deadlineAt
              )
            );
        }

        allow read: if canReadGroupBasicPoll();
        allow create, update, delete: if canManageGroupBasicPoll();

        match /votes/{userId} {
          function pollData() {
            return exists(/databases/$(database)/documents/questingGroups/$(groupId)/basicPolls/$(pollId))
              ? get(/databases/$(database)/documents/questingGroups/$(groupId)/basicPolls/$(pollId)).data
              : null;
          }

          function requesterVoteData() {
            return request.auth != null
              && exists(/databases/$(database)/documents/questingGroups/$(groupId)/basicPolls/$(pollId)/votes/$(request.auth.uid))
              ? get(/databases/$(database)/documents/questingGroups/$(groupId)/basicPolls/$(pollId)/votes/$(request.auth.uid)).data
              : null;
          }

          function hasSubmittedBasicPollVote(poll, vote) {
            return poll != null
              && vote != null
              && (
                (
                  poll.settings != null
                  && poll.settings.voteType == "RANKED_CHOICE"
                  && vote.rankings != null
                  && vote.rankings.size() > 0
                )
                || (
                  (
                    poll.settings == null
                    || poll.settings.voteType != "RANKED_CHOICE"
                  )
                  && (
                    (vote.optionIds != null && vote.optionIds.size() > 0)
                    || (
                      poll.settings != null
                      && poll.settings.allowWriteIn == true
                      && vote.otherText is string
                      && vote.otherText.size() > 0
                    )
                  )
                )
              );
          }

          function pollVoteVisibility(data) {
            return data != null
              && (
                data.voteVisibility == "hidden_while_voting"
                || data.voteVisibility == "hidden_until_all_voted"
                || data.voteVisibility == "hidden_until_finalized"
                || data.voteVisibility == "hidden"
              )
              ? data.voteVisibility
              : "full_visibility";
          }

          function pollHideVoterIdentities(data) {
            return data != null && data.hideVoterIdentities == true;
          }

          function canReadVoterIdentities(data) {
            return data != null && !pollHideVoterIdentities(data);
          }

          function canReadVotesByVisibility(data) {
            return data != null && (
              pollVoteVisibility(data) == "full_visibility"
              || (
                pollVoteVisibility(data) == "hidden_while_voting"
                && hasSubmittedBasicPollVote(data, requesterVoteData())
              )
              || (
                pollVoteVisibility(data) == "hidden_until_all_voted"
                && data.votesAllSubmitted == true
              )
              || (
                pollVoteVisibility(data) == "hidden_until_finalized"
                && data.status == "FINALIZED"
              )
            );
          }

          allow read: if canReadGroupBasicPoll()
            && (
              isRequester(userId)
              || isGroupManager(groupData())
              || canReadVoterIdentities(pollData())
              || canReadVotesByVisibility(pollData())
            );

          allow create, update: if isSignedIn()
            && isRequester(userId)
            && groupData() != null
            && isGroupMember(groupData())
            && isGroupBasicPollWritable(pollData());

          allow delete: if isSignedIn()
            && groupData() != null
            && isGroupBasicPollWritable(pollData())
            && (
              (isRequester(userId) && isGroupMember(groupData()))
              || isGroupManager(groupData())
            );
        }
      }
    }

    match /schedulers/{schedulerId} {
      function isSchedulerParticipant(data) {
        return isSchedulerParticipantData(data);
      }

      function canVoteScheduler(data) {
        return isSignedIn() && (
          isSchedulerParticipantData(data) ||
          isQuestingGroupMember(data)
        );
      }

      function isSchedulerInvitee(data) {
        return isSignedIn() && hasPendingInvite(data);
      }

      function isInviteeUpdate(data) {
        return data.pendingInvites != null
          && isSchedulerInvitee(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "participantIds",
            "pendingInvites",
            "pendingInviteMeta",
            "updatedAt"
          ])
          && data.pendingInvites.size() == request.resource.data.pendingInvites.size() + 1
          && !(userEmail() in request.resource.data.pendingInvites)
          && data.pendingInvites.hasAll(request.resource.data.pendingInvites)
          && (
            (
              request.resource.data.participantIds.size() == data.participantIds.size()
              && request.resource.data.participantIds.hasAll(data.participantIds)
            )
            || (
              request.resource.data.participantIds.size() == data.participantIds.size() + 1
              && request.auth.uid in request.resource.data.participantIds
              && request.resource.data.participantIds.hasAll(data.participantIds)
            )
            || (
              request.resource.data.participantIds.size() + 1 == data.participantIds.size()
              && request.auth.uid in data.participantIds
              && !(request.auth.uid in request.resource.data.participantIds)
              && data.participantIds.hasAll(request.resource.data.participantIds)
            )
          );
      }

      function isLinkShareJoin(data) {
        return isSignedIn()
          && data.allowLinkSharing == true
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "participantIds",
            "pendingInvites",
            "pendingInviteMeta",
            "updatedAt"
          ])
          && request.resource.data.participantIds.size() == data.participantIds.size() + 1
          && request.auth.uid in request.resource.data.participantIds
          && request.resource.data.participantIds.hasAll(data.participantIds);
      }

      function isSelfLeave(data) {
        return isSchedulerParticipant(data)
          && request.resource.data.diff(data).affectedKeys().hasOnly([
            "participantIds",
            "updatedAt"
          ])
          && request.auth.uid in data.participantIds
          && !(request.auth.uid in request.resource.data.participantIds)
          && data.participantIds.size() == request.resource.data.participantIds.size() + 1
          && data.participantIds.hasAll(request.resource.data.participantIds);
      }

      function creatorUpdateAllowed(data) {
        return isCreator(data)
          && !request.resource.data.diff(data).affectedKeys().hasAny([
            "pendingInvites",
            "pendingInviteMeta"
          ]);
      }

      allow read: if resource != null && canReadScheduler(resource.data);
      allow create: if isSignedIn()
        && isEmailVerified()
        && request.resource.data.creatorId == request.auth.uid
        && (!request.resource.data.keys().hasAny(["pendingInviteMeta"]))
        && (request.resource.data.pendingInvites == null
          || request.resource.data.pendingInvites.size() == 0);

      allow update: if creatorUpdateAllowed(resource.data)
        || isInviteeUpdate(resource.data)
        || isLinkShareJoin(resource.data)
        || isSelfLeave(resource.data);

      allow delete: if isCreator(resource.data);

      match /slots/{slotId} {
        allow read: if canReadScheduler(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data);
        allow write: if isCreator(get(/databases/$(database)/documents/schedulers/$(schedulerId)).data);
      }

      match /basicPolls/{pollId} {
        function schedulerData() {
          return exists(/databases/$(database)/documents/schedulers/$(schedulerId))
            ? get(/databases/$(database)/documents/schedulers/$(schedulerId)).data
            : null;
        }

        function pollData() {
          return exists(/databases/$(database)/documents/schedulers/$(schedulerId)/basicPolls/$(pollId))
            ? get(/databases/$(database)/documents/schedulers/$(schedulerId)/basicPolls/$(pollId)).data
            : null;
        }

        function isSchedulerEmbeddedPollWritable(scheduler, poll) {
          return scheduler == null || poll == null
            ? false
            : (
              (!(scheduler.keys().hasAny(["status"])) || scheduler.status != "CANCELLED")
              && (!(poll.keys().hasAny(["status"])) || poll.status == "OPEN")
              && (
                !(poll.keys().hasAny(["deadlineAt"]) && poll.deadlineAt != null)
                || request.time < poll.deadlineAt
              )
            );
        }

        allow read: if canReadScheduler(schedulerData());
        allow create, update, delete: if isCreator(schedulerData());

        match /votes/{userId} {
          function requesterVoteData() {
            return request.auth != null
              && exists(/databases/$(database)/documents/schedulers/$(schedulerId)/basicPolls/$(pollId)/votes/$(request.auth.uid))
              ? get(/databases/$(database)/documents/schedulers/$(schedulerId)/basicPolls/$(pollId)/votes/$(request.auth.uid)).data
              : null;
          }

          function hasSubmittedBasicPollVote(poll, vote) {
            return poll != null
              && vote != null
              && (
                (
                  poll.settings != null
                  && poll.settings.voteType == "RANKED_CHOICE"
                  && vote.rankings != null
                  && vote.rankings.size() > 0
                )
                || (
                  (
                    poll.settings == null
                    || poll.settings.voteType != "RANKED_CHOICE"
                  )
                  && (
                    (vote.optionIds != null && vote.optionIds.size() > 0)
                    || (
                      poll.settings != null
                      && poll.settings.allowWriteIn == true
                      && vote.otherText is string
                      && vote.otherText.size() > 0
                    )
                  )
                )
              );
          }

          function pollVoteVisibility(data) {
            return data != null
              && (
                data.voteVisibility == "hidden_while_voting"
                || data.voteVisibility == "hidden_until_all_voted"
                || data.voteVisibility == "hidden_until_finalized"
                || data.voteVisibility == "hidden"
              )
              ? data.voteVisibility
              : "full_visibility";
          }

          function pollHideVoterIdentities(data) {
            return data != null && data.hideVoterIdentities == true;
          }

          function canReadVoterIdentities(data) {
            return data != null && !pollHideVoterIdentities(data);
          }

          function canReadVotesByVisibility(data) {
            return data != null && (
              pollVoteVisibility(data) == "full_visibility"
              || (
                pollVoteVisibility(data) == "hidden_while_voting"
                && hasSubmittedBasicPollVote(data, requesterVoteData())
              )
              || (
                pollVoteVisibility(data) == "hidden_until_all_voted"
                && data.votesAllSubmitted == true
              )
              || (
                pollVoteVisibility(data) == "hidden_until_finalized"
                && data.status == "FINALIZED"
              )
            );
          }

          allow read: if canReadScheduler(schedulerData())
            && (
              isCreator(schedulerData())
              || isRequester(userId)
              || canReadVoterIdentities(pollData())
              || canReadVotesByVisibility(pollData())
            );

          allow create, update: if isSignedIn()
            && isRequester(userId)
            && canVoteScheduler(schedulerData())
            && isSchedulerEmbeddedPollWritable(schedulerData(), pollData());

          allow delete: if isSignedIn()
            && isSchedulerEmbeddedPollWritable(schedulerData(), pollData())
            && (
              (isRequester(userId) && canVoteScheduler(schedulerData()))
              || isCreator(schedulerData())
            );
        }
      }

      match /votes/{userId} {
        function schedulerData() {
          return exists(/databases/$(database)/documents/schedulers/$(schedulerId))
            ? get(/databases/$(database)/documents/schedulers/$(schedulerId)).data
            : null;
        }

        function requesterVoteData() {
          return request.auth != null
            && exists(/databases/$(database)/documents/schedulers/$(schedulerId)/votes/$(request.auth.uid))
            ? get(/databases/$(database)/documents/schedulers/$(schedulerId)/votes/$(request.auth.uid)).data
            : null;
        }

        function hasSubmittedSchedulerVote(vote) {
          return vote != null
            && (
              vote.noTimesWork == true
              || (
                vote.votes != null
                && vote.votes.values().hasAny(["FEASIBLE", "PREFERRED"])
              )
            );
        }

        function schedulerVoteVisibility(data) {
          return data != null
            && (
              data.voteVisibility == "hidden_while_voting"
              || data.voteVisibility == "hidden_until_all_voted"
              || data.voteVisibility == "hidden_until_finalized"
              || data.voteVisibility == "hidden"
            )
            ? data.voteVisibility
            : "full_visibility";
        }

        function schedulerHideVoterIdentities(data) {
          return data != null && data.hideVoterIdentities == true;
        }

        function canReadSchedulerVoterIdentities(data) {
          return data != null && !schedulerHideVoterIdentities(data);
        }

        function canReadSchedulerVotesByVisibility(data) {
          return data != null && (
            schedulerVoteVisibility(data) == "full_visibility"
            || (
              schedulerVoteVisibility(data) == "hidden_while_voting"
              && hasSubmittedSchedulerVote(requesterVoteData())
            )
            || (
              schedulerVoteVisibility(data) == "hidden_until_all_voted"
              && data.votesAllSubmitted == true
            )
            || (
              schedulerVoteVisibility(data) == "hidden_until_finalized"
              && data.status == "FINALIZED"
            )
          );
        }

        allow read: if canReadScheduler(schedulerData())
          && (
            isCreator(schedulerData())
            || isRequester(userId)
            || canReadSchedulerVoterIdentities(schedulerData())
            || canReadSchedulerVotesByVisibility(schedulerData())
          );
        function creatorVoteUpdateAllowed(voteData) {
          return voteData != null
            && isCreator(schedulerData())
            && request.resource.data.diff(voteData).affectedKeys().hasOnly(["votes", "updatedAt"])
            && voteData.votes != null
            && request.resource.data.votes != null
            && request.resource.data.votes.keys().hasOnly(voteData.votes.keys());
        }

        allow create, update: if isSignedIn()
          && (
            (isRequester(userId)
              && canVoteScheduler(schedulerData()))
            || creatorVoteUpdateAllowed(resource.data)
          );
        allow delete: if isSignedIn() && (
          (isRequester(userId)
            && canVoteScheduler(schedulerData()))
          || isCreator(schedulerData())
        );
      }
    }

    match /friendRequests/{requestId} {
      allow create: if false;

      allow read: if isSignedIn() && (
        resource == null ||
        request.auth.uid == resource.data.fromUserId ||
        userEmail() == resource.data.toEmail ||
        userEmail() == resource.data.fromEmail
      );

      allow update: if isSignedIn() && (
        (
          userEmail() == resource.data.toEmail &&
          resource.data.status == "pending" &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(["status", "respondedAt", "toUserId"]) &&
          request.resource.data.status in ["accepted", "declined"]
        ) ||
        (
          (request.auth.uid == resource.data.fromUserId ||
            userEmail() == resource.data.toEmail ||
            userEmail() == resource.data.fromEmail) &&
          resource.data.status == "accepted" &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(["status", "respondedAt"]) &&
          request.resource.data.status == "removed"
        )
      );

      allow delete: if isSignedIn()
        && (userEmail() == resource.data.fromEmail
          || userEmail() == resource.data.toEmail)
        && resource.data.status in ["accepted", "removed"];
    }

    match /mail/{docId} {
      allow create: if isSignedIn();
      allow read, update, delete: if false;
    }
  }
}
